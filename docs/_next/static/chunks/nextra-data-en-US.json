{"/":{"title":"About","data":{"kght6123げぐはつ書房#kght6123（げぐはつ書房）":"Webフロントエンドの開発が好きなフロントエンド・Webエンジニアです。最近はTypeScriptやReact、Next.js、Tailwind CSSなどを中心に使っています。技術書典11〜16へオンラインで参加し、個人で技術同人誌をいくつか頒布しています。よろしければ、以下のリンクからご覧ください。本ブログは技術的な内容を中心に、日々の学びや気づきを書いています。\nTwitter @kght6123\nGitHub @kght6123\n技術同人誌\nBooth\n技術書典\nAmazon"}},"/posts/markdown":{"title":"Markdown Examples","data":{"h2-heading#h2 Heading":"","h3-heading#h3 Heading":"","h4-heading#h4 Heading":"","h5-heading#h5 Heading":"","h6-heading#h6 Heading":"","emphasis#Emphasis":"This is bold textThis is italic textStrikethrough","blockquotes#Blockquotes":"Develop. Preview. Ship. – Vercel","lists#Lists":"Unordered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nOrdered\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa","code#Code":"Inline code\nexport default function Nextra({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        <link\n          rel=\"alternate\"\n          type=\"application/rss+xml\"\n          title=\"RSS\"\n          href=\"/feed.xml\"\n        />\n        <link\n          rel=\"preload\"\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\n          as=\"font\"\n          type=\"font/woff2\"\n          crossOrigin=\"anonymous\"\n        />\n      </Head>\n      <Component {...pageProps} />\n    </>\n  )\n}","tables#Tables":"Option\tDescription\tFirst\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tSecond\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\tThird\tLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.","links#Links":"Next.js\nNextra\nVercel","footnotes#Footnotes":"Footnote .\nFootnote .\nFootnote can have markupand multiple paragraphs.Footnote text."}},"/posts/todays-lesson/20240716":{"title":"きょうのまなび（2024/07/16）","data":{"":"Kanonさんの今日の学びブログをリスペクトしてみました（本人確認済み）はじめようかなーと思ったのは、単純にKanonさんの試みがとても良かったので真似したい！と前から思っていたのと、日々、学びがちゃんとできているのか？という不安があったので、自分の学びを振り返るためにも良いかなと思いました。","1-google-identity-servicesは鬼門#1. Google Identity Servicesは鬼門":"Google Identity Servicesを使って、スプレッドシートなどGoogleDriveのデータを読み取る処理を作ろうとしていますが、普通に検索すると古い情報がかなり混ざるので、なかなか上手くいかないです。こうゆうときは、やはり公式のドキュメントを読むのが一番のちかみちでした。とくに下記のgapi.auth2の古い書き方を新しい書き方に変える記事が一番、参考になりました。\nhttps://developers.google.com/identity/oauth2/web/guides/migration-to-gis?hl=ja","2-ブログは定期的に見直しが必要#2. ブログは定期的に見直しが必要":"しばらく、このブログを更新してなかったのでラフに起動してみたら、エラーで起動しませんでした。\nFirebase CLI v13.13.3 is incompatible with Node.js v16.15.1 Please upgrade Node.js to version >=18.0.0 || >=20.0.0\nどうも、firebase-toolsのバージョンが新しくなって、Node.js v16がサポートされていないようです。npxでfirebase-toolsを使うと、自動的に最新が使われるようなので、npxを使っているときは気をつけないといけないですね。とりあえずはバージョンの固定で対応しましたが、その他フレームワークなど古すぎてNode.js v18に上げると次のエラーで起動しないので、定期的に見直しをするか、バージョンとか気にしなくてよい構成にすることも大事だなーと思いました。\nnode:internal/crypto/hash:69\n  this[kHandle] = new _Hash(algorithm, xofLen);\n                  ^\nError: error:0308010C:digital envelope routines::unsupported\n    at new Hash (node:internal/crypto/hash:69:19)\n    at Object.createHash (node:crypto:133:10)\n    at module.exports (/Volumes/Develop/kght6123.page/node_modules/webpack/lib/util/createHash.js:135:53)\n    at NormalModule._initBuildHash (/Volumes/Develop/kght6123.page/node_modules/webpack/lib/NormalModule.js:417:16)\n    at handleParseError (/Volumes/Develop/kght6123.page/node_modules/webpack/lib/NormalModule.js:471:10)\n    at /Volumes/Develop/kght6123.page/node_modules/webpack/lib/NormalModule.js:503:5\n    at /Volumes/Develop/kght6123.page/node_modules/webpack/lib/NormalModule.js:358:12\n    at /Volumes/Develop/kght6123.page/node_modules/webpack/node_modules/loader-runner/lib/LoaderRunner.js:373:3\n    at iterateNormalLoaders (/Volumes/Develop/kght6123.page/node_modules/webpack/node_modules/loader-runner/lib/LoaderRunner.js:214:10)\n    at Array.<anonymous> (/Volumes/Develop/kght6123.page/node_modules/webpack/node_modules/loader-runner/lib/LoaderRunner.js:205:4)\n    at Storage.finished (/Volumes/Develop/kght6123.page/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js:55:16)\n    at /Volumes/Develop/kght6123.page/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js:91:9\n    at /Volumes/Develop/kght6123.page/node_modules/graceful-fs/graceful-fs.js:123:16\n    at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read_file_context:68:3) {\n  opensslErrorStack: [ 'error:03000086:digital envelope routines::initialization error' ],\n  library: 'digital envelope routines',\n  reason: 'unsupported',\n  code: 'ERR_OSSL_EVP_UNSUPPORTED'\n}\nNode.js v18.20.4\nNuxt3にアップデートするかNerxt.jsに移行するか、ちょっと考え中です。","3-スケジュールから遅れそうでも無理に急がない#3. スケジュールから遅れそうでも、無理に急がない":"まぁ、たびたび遅れそうになってヤバいなーと思って焦って、まず手をバリバリ動かし始めますが、結局、焦っても仕方ないので、落ち着いて、一つ一つ優先事項から確認して対処していくことが大事だなーと思いました。とりあえずなんとかなるだろう、という気持ちで、焦らずにやっていきたいです。","まとめ#まとめ":"初回なので、やけに物量が多いですが、これからは、短くまとめていけたらなーと思います。GitHubで記事を見る"}},"/photos":{"title":"Gallery","data":{"":"主に同人誌の書影を紹介しています。\nTailwind CSSまとめ ↗ \nTailwind CSSの推し理由を語る本 ↗ \nNext.jsとTailwind CSSではじめるWebアプリケーション開発！ ↗ \nVivlioStyleとRehype/RemarkではじめるCSS組版による同人誌制作！ ↗"}},"/posts/todays-lesson/20240717":{"title":"きょうのまなび（2024/07/17）","data":{"1-再google-identity-servicesは鬼門#1. （再）Google Identity Servicesは鬼門":"Google Identity Servicesはやっぱり鬼門。今日はnpm moduleが無く、CDNのjsを読むしかない点やTypeScriptの型定義がちゃんと公式から提供されていない点とか。APIのIN/OUTの情報も公式以外は色々と不正確なので、公式のPlaygroundで一度欲しい情報がとれるAPIを試してみるのが一番のちかみちでした。https://developers.google.com/oauthplayground/ とかあとは、 https://developers.google.com/drive/api/reference/rest/v3?hl=ja のページの右側にある「API」を選ぶと探せるので、「Drive」とか「Doc」を入力して「このAPIを試す」をクリックするとAPIのリクエストとレスポンスが見られるので、実際に入力して実行を試すと良い感じです。","2-nextraをセットアップしてvercelに上げた#2. NextraをセットアップしてVercelに上げた":"とりあえず、新しい記事からブログがNextraで見られる状態にはなりました。\nしばらく、使ってなかったVercelのアカウントが壊れ？ていて、アカウント削除とかすることになりましたが、、、\n感触としては、NextraはNext.jsの拡張でMarkdownを使ってブログを書けるようになりますが、パスに日本語が使えなかったりするので、ちょっと戸惑いました。少しづつ、ドメインを移行したり、UIをカスタマイズしたりしていきたいです。","3-再スケジュールから遅れそうでも無理に急がない#3. （再）スケジュールから遅れそうでも、無理に急がない":"これ大事。今日も守れなかったので最短ルートを模索しつつ、焦らずにやっていきたいです。","まとめ#まとめ":"初回なので、やけに物量が多いですが、これからは、短くまとめていけたらなーと思います。GitHubで記事を見る"}},"/posts":{"title":"Posts","data":{}},"/posts/todays-lesson/20240719":{"title":"きょうのまなび（2024/07/19）","data":{"1-python昔と全然違う#1. Python、昔と全然違う":"わたしがPythonを最後に触ったのは、2系から3系への切り替えの過渡期でした。そのときは何かしようと思ったら2や3でしか動かないとか、ライブラリが対応していないとかあって辛かったです。また、常にライブラリがグローバルにインストールされるし、静的型解析がないし、という感じでした。今回、Pythonを使う機会があって、3系での開発をしているのですが、すごく便利になっているなぁと感じました。ライブラリのインストールも仮想環境を使って、プロジェクトごとに管理や静的型解析もできるし、Node.jsのような感じで便利です。RAGやLLMを使ったとりあえず動くものを作るときには便利かなと思いました。TypeScriptと場面によって使い分けていきたいです。","2-高度に発達したウォーターフォールはアジャイルと見分けがつかないの記事を読んだ#2. 「高度に発達したウォーターフォールはアジャイルと見分けがつかない」の記事を読んだ":"https://blog.song.mu/entry/any-sufficiently-advanced-waterfall-is-indistinguishable-from-agileウォーターフォールがダメなパターンとして批判されやすいのに日頃から違和感があって、理解が深まる記事でした。ウォーターフォールでも朝会や夕会、改善や振り返りを繰り返す現場もありますし、、、その場合、ウォーターフォールでもアジャイルだなぁって思ったりします。記事中にも次のような記載があり、それを読んでウォーターフォールとアジャイルは共存できるもの？なのかなーと思いました。\nそもそも、アジャイル開発とは価値観であり、特定の開発工程や方法論のことを指しません。その価値観を共有する開発がアジャイルソフトウェア開発であり、方法論は何でも良いのです。","3-google-docsmarkdown形式でのドキュメントのエクスポートインポートなど可能にの記事を読んだ#3. 「Google Docs、Markdown形式でのドキュメントのエクスポート、インポートなど可能に」の記事を読んだ":"https://www.publickey1.jp/blog/24/google_docsmarkdow.htmlRAGのような手法でDBにデータを入れていくときに、Google Docsで書いたものをMarkdown形式でエクスポートして、それをDBに入れるということができるようになるので、とても便利そうだなと思いました。Markdownの方がLLMも解釈しやすいとよく聞くので精度的にも期待できそうです。GitHubで記事を見る"}},"/posts/todays-lesson/20240720":{"title":"きょうのまなび（2024/07/20）","data":{"1-ブログのテンプレート購入するのもありかも#1. ブログのテンプレート、購入するのもありかも？":"https://x.com/daisyui_/status/1814563629326331928次の技術書典の本もそろそろ描き始めたい（というか、もう書き始めないと筆の遅さ的に間に合わない）ので、ブログにこれ以上時間を割くのも勿体ないので、時間をお金で買うのもありかなと思いました。","2-docker互換のセキュアなコンテナ実行環境podman超入門のスライドを読んだ#2. 「Docker互換のセキュアなコンテナ実行環境「Podman」超入門」のスライドを読んだ":"https://speakerdeck.com/devops_vtj/dockerhu-huan-nosekiyuanakontenashi-xing-huan-jing-podman-chao-ru-menPodmanはDockerと互換性があるのとセキュリティ面で優れているということで、Podmanを使ってみたいなと思いました。\n（最近、Docker Desktopのバグにも苦しめられているので、、、確かに非ルートモードのインストールはめんどくさい）また、スライドの中でも紹介されていますがRedHatから無料で本がダウンロードできるそうなので時間があるときに読んでみたいです。https://developers.redhat.com/e-books/podman-action","3-linemoをesimで追加契約してはじめてiphoneをデュアルsimで使ってみた#3. LINEMOをeSIMで追加契約して、はじめてiPhoneをデュアルSIMで使ってみた":"https://www.linemo.jp元々、楽天モバイルを使っているのですが、田舎なので楽天回線が弱いときがあるので、そのときにLINEMOを使ってみたいなと思いました。あとは、データ通信を使いすぎることが（主に子供達のiPadで）あるので、超えそうなときの予備回線として・・・ちなみに使い勝手は結構良くて、2台持たなくても電話番号が2つあるので色々と使い分けられて便利そうです。\n（SoftBankユーザなら1年間だけ無料で使えるPrerplexity Proが良さそうなので、試しに無料で使いたかったという裏の目的もあります😅）GitHubで記事を見る"}},"/posts/todays-lesson":{"title":"きょうのまなび","data":{}},"/posts/pages":{"title":"Next.js Pages","data":{"":"In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about.\nfunction About() {\n  return <div>About</div>\n}\nexport default About","pages-with-dynamic-routes#Pages with Dynamic Routes":"Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.","pre-rendering#Pre-rendering":"By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)","two-forms-of-pre-rendering#Two forms of Pre-rendering":"Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request.\nServer-side Rendering: The HTML is generated on each request.\nImportantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.You can also use Client-side Rendering along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by client side JavaScript. To learn more, take a look at the Data Fetching documentation.","static-generation-recommended#Static Generation (Recommended)":"If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build . This HTML will then be reused on each request. It can be cached by a CDN.In Next.js, you can statically generate pages with or without data. Let's take a look at each case.","static-generation-without-data#Static Generation without data":"By default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:\nfunction About() {\n  return <div>About</div>\n}\nexport default About\nNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.","static-generation-with-data#Static Generation with data":"Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use a special function Next.js provides:\nYour page content depends on external data: Use getStaticProps.\nYour page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps).","scenario-1-your-page-content-depends-on-external-data#Scenario 1: Your page content depends on external data":"Example: Your blog page might need to fetch the list of blog posts from a CMS (content management system).\n// TODO: Need to fetch `posts` (by calling some API endpoint)\n//       before this page can be pre-rendered.\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\nexport default Blog\nTo fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This function gets called at build time and lets you pass fetched data to the page's props on pre-render.\nfunction Blog({ posts }) {\n  // Render posts...\n}\n// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // By returning { props: { posts } }, the Blog component\n  // will receive `posts` as a prop at build time\n  return {\n    props: {\n      posts\n    }\n  }\n}\nexport default Blog\nTo learn more about how getStaticProps works, check out the Data Fetching documentation.","scenario-2-your-page-paths-depend-on-external-data#Scenario 2: Your page paths depend on external data":"Next.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a single blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1.\nTo learn more about dynamic routing, check the Dynamic Routing documentation.\nHowever, which id you want to pre-render at build time might depend on external data.Example: suppose that you've only added one blog post (with id: 1) to the database. In this case, you'd only want to pre-render posts/1 at build time.Later, you might add the second post with id: 2. Then you'd want to pre-render posts/2 as well.So your page paths that are pre-rendered depend on external data**.** To handle this, Next.js lets you export an async function called getStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you specify which paths you want to pre-render.\n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id }\n  }))\n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\nAlso in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and use it to pre-render the page:\nfunction Post({ post }) {\n  // Render post...\n}\nexport async function getStaticPaths() {\n  // ...\n}\n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n  // Pass post data to the page via props\n  return { props: { post } }\n}\nexport default Post\nTo learn more about how getStaticPaths works, check out the Data Fetching documentation.","when-should-i-use-static-generation#When should I use Static Generation?":"We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.You can use Static Generation for many types of pages, including:\nMarketing pages\nBlog posts\nE-commerce product listings\nHelp and documentation\nYou should ask yourself: \"Can I pre-render this page ahead of a user's request?\" If the answer is yes, then you should choose Static Generation.On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.In cases like this, you can do one of the following:\nUse Static Generation with Client-side Rendering: You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation.\nUse Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.","server-side-rendering#Server-side Rendering":"Also referred to as \"SSR\" or \"Dynamic Rendering\".\nIf a page uses Server-side Rendering, the page HTML is generated on each request.To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write getServerSideProps which fetches this data and passes it to Page like below:\nfunction Page({ data }) {\n  // Render data...\n}\n// This gets called on every request\nexport async function getServerSideProps() {\n  // Fetch data from external API\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n  // Pass data to the page via props\n  return { props: { data } }\n}\nexport default Page\nAs you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every request instead of on build time.To learn more about how getServerSideProps works, check out our Data Fetching documentation","summary#Summary":"We've discussed two forms of pre-rendering for Next.js.\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request. To make a page use Static Generation, either export the page component, or export getStaticProps (and getStaticPaths if necessary). It's great for pages that can be pre-rendered ahead of a user's request. You can also use it with Client-side Rendering to bring in additional data.\nServer-side Rendering: The HTML is generated on each request. To make a page use Server-side Rendering, export getServerSideProps. Because Server-side Rendering results in slower performance than Static Generation, use this only if absolutely necessary."}},"/posts/todays-lesson/20240718":{"title":"きょうのまなび（2024/07/18）","data":{"1-cssのrelativeとabsoluteは急いでいるときは便利#1. CSSのrelativeとabsoluteは急いでいるときは便利":"ラフにとりあえずUIを追加したいときとか、やっぱり便利だな、、と。これらはあんまり既存のコードに影響されずに追加できるので、外に出ないものでそこまで保守とか気にしなくてよいもので作業を急いでいるときには助かります。既存でGridとかFlexbox使っているところにitemを追加すると他の項目を含めた調整が必要になってしまうのでその時間がないときとか。。。必要がでてきたら、ちゃんとUIもリファクターしたいですがとりあえず動くものを作るときには便利です。","2-nextraの使い方が分かってきた#2. Nextraの使い方が分かってきた":"新しい記事からブログがNextraで見られる状態にはなった状態から、トップページを整備してギャラリー作ったり、フォントを差し替えてなんとか見られる形になりました。ナビゲーションの追加のされかたとかよくわからないところも多いので、ドメインを移行したり、Twitter投稿時のサムネイル対応したりしていきたいです。","3-playwright-を使いこなすためのベストプラクティス#3. Playwright を使いこなすためのベストプラクティス":"https://qiita.com/ore88ore/items/bd5a1b65166027806096E2Eテストがよく不安定になるので試したい・・・！！！","4-es-toolkit#4. es-toolkit":"https://bestofjs.org/projects/es-toolkitlodashのメジャーアップグレードらしい。どこかで試しに使ってみたい。GitHubで記事を見る"}},"/privacy-policy":{"title":"Policy","data":{"免責事項#免責事項":"当サイトからリンクやバナーなどによって他のサイトに移動された場合、移動先サイトで提供される情報、サービス等について一切の責任を負いません。当サイトのコンテンツ・情報につきまして、可能な限り正確な情報を掲載するよう努めておりますが、誤情報が入り込んだり、情報が古くなっていることもございます。当サイトに掲載された内容によって生じた損害等の一切の責任を負いかねますのでご了承ください。","プライバシーポリシーの変更について#プライバシーポリシーの変更について":"当サイトは、個人情報に関して適用される日本の法令を遵守するとともに、本ポリシーの内容を適宜見直しその改善に努めます。修正された最新のプライバシーポリシーは常に本ページにて開示されます。以上"}},"/tags/[tag]":{"title":"Tagged Posts","data":{}}}